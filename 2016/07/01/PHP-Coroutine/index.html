<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>用PHP协程实现多任务协作 | Z - Computer &amp; Programming Technology</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google-adsense-account" content="ca-pub-8768699638326268">
  <meta name="description" content="PHP 5.5  中最重要的特性之一就是对协程（coroutine）和生成器（generator）的支持。生成器的特性已经由官方文档和许多博文（比如这一篇和这一篇）讲解得很充分了。另一方面，协程受到的关注则较少。这是因为协程的功能相较而言更加强大，但却难以讲解。 本文会使用协程实现一个任务调度器，以此帮助你理解协程的概念和用法。我会先用几个段落做一些介绍。如果你觉得你已经对生成器和协程的基本概念掌">
<meta property="og:type" content="article">
<meta property="og:title" content="用PHP协程实现多任务协作">
<meta property="og:url" content="http://log.zvz.im/2016/07/01/PHP-Coroutine/index.html">
<meta property="og:site_name" content="Z - Computer &amp; Programming Technology">
<meta property="og:description" content="PHP 5.5  中最重要的特性之一就是对协程（coroutine）和生成器（generator）的支持。生成器的特性已经由官方文档和许多博文（比如这一篇和这一篇）讲解得很充分了。另一方面，协程受到的关注则较少。这是因为协程的功能相较而言更加强大，但却难以讲解。 本文会使用协程实现一个任务调度器，以此帮助你理解协程的概念和用法。我会先用几个段落做一些介绍。如果你觉得你已经对生成器和协程的基本概念掌">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2016-07-01T00:56:55.000Z">
<meta property="article:modified_time" content="2025-07-03T18:06:35.824Z">
<meta property="article:author" content="darluc">
<meta property="article:tag" content="php">
<meta property="article:tag" content="Coroutine">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Z - Computer &amp; Programming Technology" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.geekzu.org/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8NRBEZPWYN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8NRBEZPWYN');
</script>


  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-8768699638326268",
      enable_page_level_ads: true
    });
  </script>
<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-PHP-Coroutine" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      用PHP协程实现多任务协作
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/07/01/PHP-Coroutine/" class="article-date">
  <time datetime="2016-07-01T00:56:55.000Z" itemprop="datePublished">2016-07-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tags/Coroutine/">Coroutine</a> <a class="article-category-link" href="/tags/php/">php</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>PHP 5.5  中最重要的特性之一就是对协程（coroutine）和生成器（generator）的支持。生成器的特性已经由<a target="_blank" rel="noopener" href="http://de2.php.net/manual/en/language.generators.overview.php">官方文档</a>和许多博文（比如<a target="_blank" rel="noopener" href="http://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html">这一篇</a>和<a target="_blank" rel="noopener" href="http://sheriframadan.com/2012/10/test-drive-php-5-5-a-sneak-peek/#generators">这一篇</a>）讲解得很充分了。另一方面，协程受到的关注则较少。这是因为协程的功能相较而言更加强大，但却难以讲解。</p>
<p>本文会使用协程实现一个任务调度器，以此帮助你理解协程的概念和用法。我会先用几个段落做一些介绍。如果你觉得你已经对生成器和协程的基本概念掌握得很牢固了，那么你可以直接跳至“多任务协作”这一段开始阅读。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器背后最原始的想法就是一个函数不仅仅返回一次数据，而是能够返回一系列的数据，并且这些数据是挨个返回的。也可以理解为，生成器使你能更方便地实现迭代器。<code>xrange()</code> 函数就是一个生成器的简单例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span>(<span class="params"><span class="variable">$start</span>, <span class="variable">$end</span>, <span class="variable">$step</span> = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable">$start</span>; <span class="variable">$i</span> &lt;= <span class="variable">$end</span>; <span class="variable">$i</span> += <span class="variable">$step</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">xrange</span>(<span class="number">1</span>, <span class="number">1000000</span>) <span class="keyword">as</span> <span class="variable">$num</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$num</span>, <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上例中的 <code>xrange()</code> 函数与内置函数 <code>range()</code> 函数的功能相同。唯一的区别在于 <code>range()</code> 会返回一个包含了一百万个数字的数组，而 <code>xrange()</code> 则返回一个可以吐出这些数字的迭代器，不会去老实地计算出一个包含所有数字的数组。</p>
<p>这样做的好处是显而易见的。它使得你可以处理超大规模的数据，而无需一次性将它们载入内存。你甚至可以处理无穷无尽的数据流。</p>
<p>当然并不是只有生成器能做到这一点，你也可以通过实现一个 <code>iterator</code> 接口来完成同样的工作。生成器只是更加方便，避免你为了生成一个迭代器而不得不去实现该接口的五个不同方法。</p>
<h2 id="将生成器用作可中断函数"><a href="#将生成器用作可中断函数" class="headerlink" title="将生成器用作可中断函数"></a>将生成器用作可中断函数</h2><p>要从对生成器的理解过度到协程的概念，理解它们内部的工作方式是非常重要的：生成器是可中断的函数，而 <code>yield</code> 语句则构成了这些中断点。</p>
<p>接着刚才的例子，当你调用  <code>xrange(1, 1000000)</code> 时，实际上 <code>xrange()</code> 没有执行任何代码。取而代之地，PHP 仅返回了一个 <code>Generator</code> 类的实例，它实现了 <code>Iterator</code> 接口：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$range</span> = <span class="title function_ invoke__">xrange</span>(<span class="number">1</span>, <span class="number">1000000</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$range</span>); <span class="comment">// object(Generator)#1</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$range</span> <span class="keyword">instanceof</span> <span class="built_in">Iterator</span>); <span class="comment">// bool(true)</span></span><br></pre></td></tr></table></figure>
<p>只有当你调用 iterator 接口相关的方法时代码才会执行。例如，你执行 <code>$range-&gt;rewind()</code> 时，<code>xrange()</code> 函数中的代码就会执行，直到流程中的第一条 <code>yield</code> 语句。如此一来，就意味着 <code>$i = $start</code> 和 <code>yield $i</code> 被执行了。任何传递给 <code>yield</code> 语句的数据都能通过 <code>$range-&gt;current()</code> 来获取。</p>
<p>你需要调用 <code>$range-&gt;next()</code> 方法来继续执行生成器中的代码。这样它就会继续执行下去，直到下一条 <code>yield</code> 语句。所以只要连续地调用 <code>-&gt;next()</code> 和 <code>-&gt;current()</code> 方法，你就可以从生成器中获取到所有的返回值，直至最终不再遇到 <code>yield</code> 语句。对于 <code>xrange()</code> 函数来说，就是 <code>$i</code> 超出 <code>$end</code> 的时候。如此一来，流程会继续执行完剩余的代码，直至函数的结尾。若此时调用 <code>-&gt;valid()</code> 方法则会返回 false，这个迭代过程就结束了。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>相对于上述功能，协程最主要的一点就是加入了向生成器中发送数据的能力。这使得从生成器到调用者的单向数据流，变成了两者彼此往来的数据通路。</p>
<p>将数据传递给协程的方法是调用 <code>-&gt;send()</code> 方法，而不是 <code>-&gt;next()</code>。下面的这个 <code>logger()</code> 的例子展示了它是如何工作的：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params"><span class="variable">$fileName</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$fileHandle</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$fileName</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fileHandle</span>, <span class="keyword">yield</span> . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$logger</span> = <span class="title function_ invoke__">logger</span>(<span class="keyword">__DIR__</span> . <span class="string">&#x27;/log&#x27;</span>);</span><br><span class="line"><span class="variable">$logger</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="string">&#x27;Foo&#x27;</span>);</span><br><span class="line"><span class="variable">$logger</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="string">&#x27;Bar&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如你所见，在这里 <code>yield</code> 没有被用作一个语句，而是作为一个表达式，也是就说它有一个返回值。这个返回值是通过 <code>-&gt;send()</code> 语句传过来的。此例中 <code>yield</code> 会先返回 ‘Foo’ 再返回 ‘Bar’。</p>
<p>上面的例子中 <code>yield</code> 仅仅只是作为一个接收者。实际上可以把两者结合起来，使其既可以发送也可以接收数据。例子如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$ret</span> = (<span class="keyword">yield</span> <span class="string">&#x27;yield1&#x27;</span>);</span><br><span class="line">  <span class="title function_ invoke__">var_dump</span>(<span class="variable">$ret</span>);</span><br><span class="line">  <span class="variable">$ret</span> = (<span class="keyword">yield</span> <span class="string">&#x27;yield2&#x27;</span>);</span><br><span class="line">  <span class="title function_ invoke__">var_dump</span>(<span class="variable">$ret</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$gen</span> = <span class="title function_ invoke__">gen</span>();</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">current</span>()); <span class="comment">// string(6) &quot;yield1&quot;</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="string">&#x27;ret1&#x27;</span>)); <span class="comment">// string(4) &quot;ret1&quot; (gen 函数中的第一个 var_dump)</span></span><br><span class="line">						    <span class="comment">// string(6) &quot;yield2&quot; ( -&gt;send() 返回值的 var_dump)</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="string">&#x27;ret2&#x27;</span>)); <span class="comment">// string(4) &quot;ret2&quot; (又是 gen 函数中的 var_dump)</span></span><br><span class="line">						    <span class="comment">// NULL ( -&gt;send() 的返回值)</span></span><br></pre></td></tr></table></figure>
<p>猛地一看，这些输出的顺序可能会有些难以理解，所以请多阅读几遍以确保你理解了它为何会如此输出。这儿有两点我要特别指出的：第一，使用括号将 <code>yield</code> 语句引起来不是随意为之的。由于技术原因这些括号是必须的。第二，你可能已经注意到了，我们在调用 <code>-&gt;current()</code> 之前没有调用 <code>-&gt;rewrind()</code> 方法。像这样做，rewind 操作实际被隐式的执行了。</p>
<h2 id="多任务协作"><a href="#多任务协作" class="headerlink" title="多任务协作"></a>多任务协作</h2><p>如果你看了上文 <code>logger()</code> 的例子，可能会想“为啥我要用协程做这事呢？为何我不直接用使用一个普通的类？”，当然你是绝对没错的。这个例子只是展示了协程的基本用法，但这样做却没有得到任何实际的好处。这只是许多协程示例中的一个而已。我已经说过协程是一个非常 NB 的概念，但是它们的应用却很少而且常常比较复杂，使得它很难举出一个简单而又不装的例子。</p>
<p>本文我决定用一个多任务协作的实现作为例子。目标是要能够并行地执行多个任务（或者“程序段”）。可是一个处理器只能处理一个任务（不考虑多核的情况）。这样一来，就需要处理器在多个不同的任务之间切换，让每一个任务都“运行一小会儿”。</p>
<p>“协作”的部分描述了这种切换的实现方式：它要求当前执行的任务自愿地将控制权返还给调度器，让其它的任务可以执行。这是相对于“优先调度“这种多任务调度方式而言的，优先调度方式下调度器可以在任务执行期间中断它，无论它是否自愿。协作式多任务被运用于早期版本的 Windows（Win95 之前）和 Mac OS，但之后它们都采用了优先调度的方式。原因很简单：如果你依赖于一个程序主动交出控制权，那么恶意软件就能很容易地占用全部的 CPU 资源，而不给其它任务留下任何执行的机会。</p>
<p>此时你应该可以看出协程和任务调度之间的关联了：<code>yield</code> 指令提供了一种方式，使得任务可以自我中断，将控制权交还调度器，让别的任务得以执行。而且 <code>yield</code> 指令还可以用于任务和调度器之间的数据交互。</p>
<p>对于我们的最终实现来讲，一个“任务”将会是对协程函数的简单包裹类：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$taskId</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$coroutine</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$sendValue</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$beforeFirstYield</span> = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$taskId</span>, <span class="built_in">Generator</span> <span class="variable">$coroutine</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;taskId = <span class="variable">$taskId</span>;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;coroutine = <span class="variable">$coroutine</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;taskd;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span>(<span class="params"><span class="variable">$sendValue</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;sendValue = <span class="variable">$sendValue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;beforeFirstYield) &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;beforeFirstYield = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;coroutine-&gt;<span class="title function_ invoke__">current</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable">$retval</span> = <span class="variable language_">$this</span>-&gt;coroutine-&gt;<span class="title function_ invoke__">send</span>(<span class="variable">$this</span>-&gt;sendValue);</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;sendValue = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable">$retval</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">$this</span>-&gt;coroutine-&gt;<span class="title function_ invoke__">valid</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个任务是一个由任务 ID 标识的协程。使用 <code>setSendValue()</code> 你可以设定下一次获得执行时，传递给协程的数据（之后你会看到我们需要它做些什么）。<code>run()</code> 方法实际上什么都不用做，只是调用协程的 <code>send()</code> 方法。为了理解额外的 <code>beforeFirstYield</code> 属性，我们可以考虑以下的代码片段：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$gen</span> = <span class="title function_ invoke__">gen</span>();</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="string">&#x27;something&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 send() 发生时，在第一次 yield 之前，有一次隐式的 rewind() 调用</span></span><br><span class="line"><span class="comment">// 所以实际发生的过程是这样的：</span></span><br><span class="line"><span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">rewind</span>();</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="string">&#x27;something&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// rewind() 调用时会执行到第一个 yield 处(并且忽略它的值)，send() 调用时会前进至第二个 yield 处（并且抛出它的值）。这样的话，我们就会失去第一个 yield 的值！</span></span><br></pre></td></tr></table></figure>
<p>通过增加额外的 <code>beforeFirstYield</code> 属性，可以保证第一次 yield 的值也可以正确地返回。</p>
<p>调度器只需要循环执行这些任务即可：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$maxTaskId</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$taskMap</span> = []; <span class="comment">// taskId =&gt; task</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$taskQueue</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;taskQueue = <span class="keyword">new</span> <span class="built_in">SplQueue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span>(<span class="params"><span class="built_in">Generator</span> <span class="variable">$coroutine</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$tid</span> = ++<span class="variable language_">$this</span>-&gt;maxTaskId;</span><br><span class="line">    <span class="variable">$task</span> = <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="variable">$tid</span>, <span class="variable">$coroutine</span>);</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;taskMap[<span class="variable">$tid</span>] = <span class="variable">$task</span>;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">schedule</span>(<span class="variable">$task</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$tid</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span>(<span class="params">Task <span class="variable">$task</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;taskQueue-&gt;<span class="title function_ invoke__">enqueue</span>(<span class="variable">$task</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="variable language_">$this</span>-&gt;taskQueue-&gt;<span class="title function_ invoke__">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="variable">$task</span> = <span class="variable language_">$this</span>-&gt;taskQueue-&gt;<span class="title function_ invoke__">dequeue</span>();;;</span><br><span class="line">      <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$task</span>-&gt;<span class="title function_ invoke__">isFinished</span>()) &#123;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;taskMap[<span class="variable">$task</span>-&gt;<span class="title function_ invoke__">getTaskId</span>()]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">schedule</span>(<span class="variable">$task</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newTask()</code> 方法用于创建任务并把它放入任务对照表中。此外它把任务放入任务队列，以此来安排任务的执行。<code>run()</code> 方法用于遍历这个任务队列，并执行任务。如果一个任务完成了，那么它会被从队列中移除，否则它会被重新排在队列尾部。</p>
<p>让我们用两个简单（且无意义的）任务，来测试一下调度器：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">10</span>; ++<span class="variable">$i</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;This is task 1 iteration <span class="subst">$i</span>.\n&quot;</span>:</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">5</span>; ++<span class="variable">$i</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;This is task 2 iteration <span class="subst">$i</span>.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span> = <span class="keyword">new</span> <span class="title class_">Scheduler</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">task1</span>());</span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">task2</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">run</span>();;</span><br></pre></td></tr></table></figure>
<p>两个任务都是只是打印出一条信息，然后使用 <code>yield</code> 将控制权交还给调度器。以下是输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This is task 1 iteration 1.</span><br><span class="line">This is task 2 iteration 1.</span><br><span class="line">This is task 1 iteration 2.</span><br><span class="line">This is task 2 iteration 2.</span><br><span class="line">This is task 1 iteration 3.</span><br><span class="line">This is task 2 iteration 3.</span><br><span class="line">This is task 1 iteration 4.</span><br><span class="line">This is task 2 iteration 4.</span><br><span class="line">This is task 1 iteration 5.</span><br><span class="line">This is task 2 iteration 5.</span><br><span class="line">This is task 1 iteration 6.</span><br><span class="line">This is task 1 iteration 7.</span><br><span class="line">This is task 1 iteration 8.</span><br><span class="line">This is task 1 iteration 9.</span><br><span class="line">This is task 1 iteration 10.</span><br></pre></td></tr></table></figure>
<p>与预期一致：前5次迭代两个任务是交替进行的，然后当第二个任务结束了，只剩下第一个在继续执行。</p>
<h2 id="与调度器进行交互"><a href="#与调度器进行交互" class="headerlink" title="与调度器进行交互"></a>与调度器进行交互</h2><p>至此调度器已经可以工作，我们就能开始进行下一事项了：任务与调度器的数据交互。我们将使用进程与操作系统之间一样的交互方法：系统调用（system call）。我们需要系统调用，是由于操作系统和进程应当运行在不同的特权级别。 所以为了进行某些特权操作（比如杀死其它的进程），必须得有方法将控制交给内核，让内核去执行。从内部看这又是通过中断指令来实现的。早期我们使用的是原生的 <code>int</code> 指令，现如今则有了更专业且更快速的 <code>syscall/sysenter</code> 指令。</p>
<p>我们的任务调度系统将会反应出这种设计：不是简单地将调度器传递给任务（这样会使得任务能够为所欲为），我们会通过 <code>yield</code> 表达式让它们以系统调用的方式进行交互。<code>yield</code> 在这里不仅起到中断的作用，同时也负责传递信息给调度器。</p>
<p>我们用一个 <code>callable</code> 对象的包裹类来描述一个系统调用：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$callback</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__cosntruct</span>(<span class="params"><span class="keyword">callable</span> <span class="variable">$callback</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;callback = <span class="variable">$callback</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params">Task <span class="variable">$task</span>, Scheduler <span class="variable">$scheduler</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$callback</span> = <span class="variable language_">$this</span>-&gt;callback; <span class="comment">// 不能从 PHP 中直接调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$callback</span>(<span class="variable">$task</span>, <span class="variable">$scheduler</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会表现得如任何可调用对象一样（通过 <code>__invoke</code> 方法），但是让调度器将调用的任务和它自己一起传递至函数内。为了使用它，我们需要小小地修改一下调度器的 <code>run</code> 方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>( !<span class="variable language_">$this</span>-&gt;taskQueue-&gt;<span class="title function_ invoke__">isEmpty</span>() ) &#123;</span><br><span class="line">    <span class="variable">$task</span> = <span class="variable language_">$this</span>-&gt;taskQueue-&gt;<span class="title function_ invoke__">dequeue</span>();</span><br><span class="line">    <span class="variable">$retval</span> = <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$retval</span> instanceOf SystemCall) &#123;</span><br><span class="line">      <span class="variable">$retval</span>(<span class="variable">$task</span>, <span class="variable language_">$this</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$task</span>-&gt;<span class="title function_ invoke__">isFinished</span>()) &#123;</span><br><span class="line">      <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;taskMap[<span class="variable">$task</span>-&gt;<span class="title function_ invoke__">getTaskId</span>()]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">schedule</span>(<span class="variable">$task</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个系统调用什么都不做，只是返回任务 ID 号：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SystemCall</span>(<span class="function"><span class="keyword">function</span>(<span class="params">Task <span class="variable">$task</span>, Scheduler <span class="variable">$scheduler</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">setSendValue</span>(<span class="variable">$task</span>-&gt;<span class="title function_ invoke__">getTaskId</span>());</span><br><span class="line">    <span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">schedule</span>(<span class="variable">$task</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的实现方式是将 tid 设置为下一个发送的数据并且重排任务。对于系统调用，调度器并不自动重排任务，我们需要手动控制（后面你就会知道为什么）。我们可以利用系统调用重写之前的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params"><span class="variable">$max</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$tid</span> = (<span class="keyword">yield</span> <span class="title function_ invoke__">getTaskId</span>()); <span class="comment">// &lt;-- 这里使用了系统调用</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="variable">$max</span>; ++<span class="variable">$i</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;This is task <span class="subst">$tid</span> iteration <span class="subst">$i</span>.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span> = <span class="keyword">new</span> <span class="title class_">Scheduler</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">task</span>(<span class="number">10</span>));</span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">task</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>
<p>代码输出还是和之前一样。注意是如何进行系统调用的，基本上和普通函数一样只是前面多加了一个 <code>yield</code> 。下面还有两个系统调用分别用于创建任务和删除任务：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newTask</span>(<span class="params"><span class="built_in">Generator</span> <span class="variable">$coroutine</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SystemCall</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">Task <span class="variable">$task</span>, Scheduler <span class="variable">$scheduler</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$coroutine</span></span>) </span>&#123;</span><br><span class="line">      <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">setSendValue</span>(<span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">newTask</span>(<span class="variable">$coroutine</span>));</span><br><span class="line">      <span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">schedule</span>(<span class="variable">$task</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">killTask</span>(<span class="params"><span class="variable">$tid</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SystemCall</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">Task <span class="variable">$task</span>, Scheduler <span class="variable">$scheduler</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$tid</span></span>) </span>&#123;</span><br><span class="line">      <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">setSendValue</span>(<span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">killTask</span>(<span class="variable">$tid</span>));</span><br><span class="line">      <span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">schedule</span>(<span class="variable">$task</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>killTask</code> 函数的实现需要在调度器里加一个方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">killTask</span>(<span class="params"><span class="variable">$tid</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;taskMap[<span class="variable">$tid</span>])) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;taskMap[<span class="variable">$tid</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里的代码有点烂，其实可以优化让它不用遍历整个队列的，</span></span><br><span class="line">  <span class="comment">// 但我这里暂时不管它了，就假设杀进程不是那么常用的吧</span></span><br><span class="line">  <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;taskQueue <span class="keyword">as</span> <span class="variable">$i</span> =&gt; <span class="variable">$task</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$task</span>-&gt;<span class="title function_ invoke__">getTaskId</span>() === <span class="variable">$tid</span>) &#123;</span><br><span class="line">      <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;taskQueue[<span class="variable">$i</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用下面一小段代码来测试新功能：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$tid</span> = (<span class="keyword">yield</span> <span class="title function_ invoke__">genTaskId</span>());</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Child task <span class="subst">$tid</span> still alive!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$tid</span> = (<span class="keyword">yield</span> <span class="title function_ invoke__">getTaskId</span>());</span><br><span class="line">  <span class="variable">$childTid</span> = (<span class="keyword">yield</span> <span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">childTask</span>()));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">6</span>; ++<span class="variable">$i</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Parent task <span class="subst">$tid</span> iteration <span class="subst">$i</span>.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$i</span> == <span class="number">3</span>) <span class="keyword">yield</span> <span class="title function_ invoke__">killTask</span>(<span class="variable">$childTid</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span> = <span class="keyword">new</span> <span class="title class_">Scheduler</span>;</span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">task</span>());</span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>
<p>这将输出以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Parent task 1 iteration 1.</span><br><span class="line">Child task 2 still alive!</span><br><span class="line">Parent task 1 iteration 2.</span><br><span class="line">Child task 2 still alive!</span><br><span class="line">Parent task 1 iteration 3.</span><br><span class="line">Child task 2 still alive!</span><br><span class="line">Parent task 1 iteration 4.</span><br><span class="line">Parent task 1 iteration 5.</span><br><span class="line">Parent task 1 iteration 6.</span><br></pre></td></tr></table></figure>
<p>子任务在三次迭代后被清除，不再输出“Child is still alive“。有人可能会指出这并不是真正的父子关系，因为在父任务结束运行后，子任务仍然可以继续运行。甚至子任务也可以终止父任务。也许有人可以修改一下调度器，实现一个更有层次的任务结构，不过在本文中我们不会去做这件事。</p>
<p>还有很多进程管理调用可以去实现，比如 <code>wait</code> （等待直至某个任务执行完成），<code>exec</code> （用于替代当前任务）还有 <code>fork</code> （克隆当前运行的任务）。分路（forking）相当的酷，你可以利用 PHP 的协程来实现它，因为它们也支持克隆操作。</p>
<p>不过我会把这些留给感兴趣的读者，让我们开始下一个话题。</p>
<h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>用我们的任务管理系统来实现一个 web 服务器是一件很牛的事情。可以用一个任务用来监听 socket 建立新连接，每当一个新连接建立时，就创建一个新的任务负责处理它。</p>
<p>困难的部分在于一般的 socket 操作是阻塞的（比如读取数据）。PHP 会一直阻塞直到客户端完成数据发送。对于一个 web 服务器来说显然是不能接受的：这相当于它每次只能处理一个连接。</p>
<p>解决办法是在实际读写前，确保 socket 是“就绪”状态。为了找出哪些 socket 处于可读取或可写状态，我们可以使用 <code>stream_select</code> 方法。</p>
<p>首先，我们加入两个新的系统调用，可以使得一个任务在 socket 就绪前一直等待。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForRead</span>(<span class="params"><span class="variable">$socket</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SystemCall</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">Task <span class="variable">$task</span>, Scheduler <span class="variable">$scheduler</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$socket</span></span>) </span>&#123;</span><br><span class="line">      <span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">waitForRead</span>(<span class="variable">$socket</span>, <span class="variable">$task</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForWrite</span>(<span class="params"><span class="variable">$socket</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SystemCall</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">Task <span class="variable">$task</span>, Scheduler <span class="variable">$scheduler</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$socket</span></span>) </span>&#123;</span><br><span class="line">      <span class="variable">$scheduler</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些系统调用就是调度器中对应方法的代理：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resourceID =&gt; [socket, tasks]</span></span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$waitingForRead</span> = [];</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$waitingForWrite</span> = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">waitForRead</span>(<span class="params"><span class="variable">$socket</span>, Task <span class="variable">$task</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;waitingForRead[(<span class="keyword">int</span>) <span class="variable">$socket</span>])) &#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;waitingForRead[(<span class="keyword">int</span>) <span class="variable">$socket</span>][<span class="number">1</span>][] = <span class="variable">$task</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;waitingForRead[(<span class="keyword">int</span>) <span class="variable">$socket</span>] = [<span class="variable">$socket</span>, [<span class="variable">$task</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">waitForWrite</span>(<span class="params"><span class="variable">$socket</span>, Task <span class="variable">$task</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;waitForWrite[(<span class="keyword">int</span>) <span class="variable">$socket</span>])) &#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;waitingForWrite[(<span class="keyword">int</span>) <span class="variable">$socket</span>][<span class="number">1</span>][] = <span class="variable">$task</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;waitingForWrite[(<span class="keyword">int</span>) <span class="variable">$socket</span>] = [<span class="variable">$socket</span>, [<span class="variable">$task</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>waitingForRead</code> 和 <code>waitingForWrite</code> 两个属性用于记录被等待的 socket 和等待它们的任务。下面这个方法很有趣，它实现了检查 socket 的就绪状态和重排对应任务的功能：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">ioPoll</span>(<span class="params"><span class="variable">$timeout</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$rSocks</span> = [];</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;waitingForRead <span class="keyword">as</span> <span class="keyword">list</span>(<span class="variable">$socket</span>)) &#123;</span><br><span class="line">    <span class="variable">$rSocks</span>[] = <span class="variable">$socket</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$wSocks</span> = [];</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;waitingForWrite <span class="keyword">as</span> <span class="keyword">list</span>(<span class="variable">$sockets</span>)) &#123;</span><br><span class="line">    <span class="variable">$wSocks</span>[] = <span class="variable">$socket</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$eSocks</span> = []; <span class="comment">// dummy</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_ invoke__">stream_select</span>(<span class="variable">$rSocks</span>, <span class="variable">$wSocks</span>, <span class="variable">$eSocks</span>, <span class="variable">$timeout</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">foreach</span> (<span class="variable">$rSocks</span> <span class="keyword">as</span> <span class="variable">$socket</span>) &#123;</span><br><span class="line">    <span class="keyword">list</span>(, <span class="variable">$tasks</span>) = <span class="variable language_">$this</span>-&gt;waitingForRead[(<span class="keyword">int</span>) <span class="variable">$socket</span>];</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;waitingForRead[(<span class="keyword">int</span>) <span class="variable">$socket</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$tasks</span> <span class="keyword">as</span> <span class="variable">$task</span>) &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">schedule</span>(<span class="variable">$task</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stream_select</code> 函数接受读／写／排除的 sockets 数组作为检验参数（忽略最后一个数组中的）。这些数组都是引用传参，执行完成后函数会留下状态发生变化的那些。然后我们就可以遍历这些数组，并且重排那些与之关联的任务了。</p>
<p>为了规律地执行上面的轮询操作，我们要在调度器中加入一个特别的任务：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">ioPollTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;taskQueue-&gt;<span class="title function_ invoke__">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">ioPoll</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">ioPoll</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个任务需要在某处被加入调度，比如可以在 <code>run()</code> 方法开始处加入 <code>$this-&gt;newTask($this-&gt;ioPollTask())</code> 。然后它就会像其它的任务一样工作，每个完整的任务循环中执行一次（这不一定是最好的处理方案）。<code>ioPollTask</code> 会调用 <code>ioPoll</code> ，且超时参数设置为 <code>0</code> ，使得 <code>stream_select</code> 函数可以立即返回（不会阻塞）。</p>
<p>只有当任务队列为空时，我们给超时参数传入 <code>null</code> ，使得它会阻塞直到某个 socket 就绪。如果不这样做，就会使得轮询任务不断地被执行直到产生一个新连接。这会造成 CPU 达到 100% 的使用率。所以让操作系统在此等待会更有效率。</p>
<p>现在，要完成服务器代码相对容易很多：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">server</span>(<span class="params"><span class="variable">$port</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;Strating server as port <span class="subst">$port</span>...\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$socket</span> = @<span class="title function_ invoke__">stream_socket_server</span>(<span class="string">&quot;tcp://localhost:<span class="subst">$port</span>&quot;</span>, <span class="variable">$errNo</span>, <span class="variable">$errStr</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable">$socket</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="variable">$errStr</span>, <span class="variable">$errNo</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="title function_ invoke__">stream_set_blocking</span>(<span class="variable">$socket</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">waitForRead</span>(<span class="variable">$socket</span>);</span><br><span class="line">    <span class="variable">$clientSocket</span> = <span class="title function_ invoke__">stream_socket_accept</span>(<span class="variable">$socket</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">handleClient</span>(<span class="variable">$clientSocket</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClient</span>(<span class="params"><span class="variable">$socket</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_ invoke__">waitForRead</span>(<span class="variable">$socket</span>);</span><br><span class="line">  <span class="variable">$data</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$socket</span>, <span class="number">8192</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$msg</span> = <span class="string">&quot;Received following request:\n\n<span class="subst">$data</span>&quot;</span>;</span><br><span class="line">  <span class="variable">$msgLength</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$msg</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$response</span> = <span class="string">&lt;&lt;&lt;RES</span></span><br><span class="line"><span class="string">HTTP/1.1 200 OK\r</span></span><br><span class="line"><span class="string">Content-Type: text/plain\r</span></span><br><span class="line"><span class="string">Content-Length: <span class="subst">$msgLength</span>\r</span></span><br><span class="line"><span class="string">Connection: close\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string"><span class="subst">$msg</span></span></span><br><span class="line"><span class="string">RES</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_ invoke__">waitForWrite</span>(<span class="variable">$socket</span>);</span><br><span class="line">  <span class="title function_ invoke__">fwrite</span>(<span class="variable">$socket</span>, <span class="variable">$reponse</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="title function_ invoke__">fclose</span>(<span class="variable">$socket</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span> = <span class="keyword">new</span> <span class="title class_">Scheduler</span>;</span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">server</span>(<span class="number">8000</span>));</span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>
<p>这段代码能接受 <code>localhost:8000</code> 的连接，并发回一个 HTTP 响应，包含它发送过来的内容。现实情况则要复杂得多（讨论如何恰当地处理 HTTP 请求已经超出了本文的范围）。以上代码仅是一个通常意义上的示例。</p>
<p>你可以用 <code>ab -n 1000 -c 100 localhost:8000/</code> 来测试这个服务代码。这可以一百并发地发送一万次请求。在这种压力下我得到的响应时长为十毫秒。但会有一些问题，某些请求处理得<em>非常慢</em>（约五秒），导致总吞吐量只有每秒两千次请求（如果一个请求只耗时十毫秒的话，应当接近每秒一万次请求）。采用更高的并发时（比如 <code>-c 500</code> ）绝大多数时候还是工作正常，除了某些连接抛出了“Connection reset by peer“的错误。由于我对这些底层的 socket 事情了解较少，所以也没去探究其原因。</p>
<h2 id="栈式协程"><a href="#栈式协程" class="headerlink" title="栈式协程"></a>栈式协程</h2><p>如果你想用我们的调度系统构建一个更大的系统，那么很快就会遇到这个问题：我们习惯于将代码拆散为更小的功能函数进行调用。使用协程时却无法做到了。比如考虑一下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoTimes</span>(<span class="params"><span class="variable">$msg</span>, <span class="variable">$max</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="variable">$max</span>; ++<span class="variable">$i</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$msg</span> iteration <span class="subst">$i</span>\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">echoTimes</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="number">10</span>); <span class="comment">// 输出10次 foo</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;---\n&quot;</span>;</span><br><span class="line">  <span class="title function_ invoke__">echoTimes</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="number">5</span>); <span class="comment">// 输出5次 bar</span></span><br><span class="line">  <span class="keyword">yield</span>; <span class="comment">// 强制转换为一个协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$scheduler</span> = <span class="keyword">new</span> <span class="title class_">Scheduler</span>;</span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">newTask</span>(<span class="title function_ invoke__">task</span>());</span><br><span class="line"><span class="variable">$scheduler</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>
<p>代码想要把反复用到的“输出 n 次”这段代码作为一个独立的协程，然后在主任务中调用它。但是却不能正常工作。就像文章开头提到的生成器（或协程）本身不做任何事情，它只是返回一个对象。上面这个例子中即印证了此事。<code>echoTimes</code> 调用除了返回一个（未使用）的协程对象外，什么也不会做。</p>
<p>为了使其能正常工作，我们需要为协程对象写一个小小的包裹类。我将其命名为“栈式协程”（ stacked coroutine ），因为它会管理一个嵌套的协程调用栈。它可以通过 yield 调用子协程：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$retval</span> = (<span class="keyword">yield</span> <span class="title function_ invoke__">someCoroutine</span>(<span class="variable">$foo</span>, <span class="variable">$bar</span>));</span><br></pre></td></tr></table></figure>
<p>子协程也能返回数据，还是使用 <code>yield</code> :</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="title function_ invoke__">retval</span>(<span class="string">&quot;I&#x27;m a return value!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个 <code>retval</code> 函数仅仅只是返回一个数据的包裹对象，表明自己是一个返回值：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineReturnValue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$value</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;value = <span class="variable">$value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retval</span>(<span class="params"><span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CoroutineReturnValue</span>(<span class="variable">$value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要将一个协程转化为一个栈式协程（支持子调用），我们还需要另一个函数（显然又是一个协程）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackedCoroutine</span>(<span class="params"><span class="built_in">Generator</span> <span class="variable">$gen</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$stack</span> = <span class="keyword">new</span> <span class="built_in">SplStack</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="variable">$value</span> = <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">current</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$value</span> <span class="keyword">instanceof</span> <span class="built_in">Generator</span>) &#123;</span><br><span class="line">      <span class="variable">$stack</span>-&gt;<span class="title function_ invoke__">push</span>(<span class="variable">$gen</span>);</span><br><span class="line">      <span class="variable">$gen</span> = <span class="variable">$value</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$isReturnValue</span> = <span class="variable">$value</span> <span class="keyword">instanceof</span> CoroutineReturnValue;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">valid</span>() || <span class="variable">$isReturnValue</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable">$stack</span>-&gt;<span class="title function_ invoke__">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="variable">$gen</span> = <span class="variable">$stack</span>-&gt;<span class="title function_ invoke__">pop</span>();</span><br><span class="line">      <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="variable">$isReturnValue</span> ? <span class="variable">$value</span>-&gt;<span class="title function_ invoke__">getValue</span>() : <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="keyword">yield</span> <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">key</span>() =&gt; <span class="variable">$value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法充当着调用者和当前运行的子协程的代理。它是在这一行 <code>$gen-&gt;send(yield $gen-&gt;key() =&gt; $value);</code> 进行处理的。此外还检验返回值是否生成器，如果是就开始执行它，并将之前的协程压入栈中。一旦得到一个 <code>CoroutineReturnValue</code> 就会从栈中取出，继续执行之前的协程。</p>
<p>要使栈式协程在任务中可以使用，<code>Task</code> 构造器中的 <code>$this-&gt;coroutine = $coroutine;</code> 这一行需要被替换为 <code>$this-&gt;coroutine = stackedCoroutine($coroutine);</code> 。</p>
<p>现在我们可以改进 web 服务器的例子，把 wait+read （还有 wait+write 和 wait+accept）这些动作组合为函数。我将用一个类把相关功能整合在一起：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoSocket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$socket</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$socket</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;socket = <span class="variable">$socket</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">accept</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">waitForRead</span>(<span class="variable">$this</span>-&gt;socket);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">retval</span>(<span class="keyword">new</span> <span class="title class_">CoSocket</span>(<span class="title function_ invoke__">stream_socket_accept</span>(<span class="variable">$this</span>-&gt;socket, <span class="number">0</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"><span class="variable">$size</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">waitForRead</span>(<span class="variable">$this</span>-&gt;socket);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">retval</span>(<span class="title function_ invoke__">fread</span>(<span class="variable">$this</span>-&gt;socket, <span class="variable">$size</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">waitForWrite</span>(<span class="variable">$this</span>-&gt;socket);</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$this</span>-&gt;socket, <span class="variable">$string</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    @<span class="title function_ invoke__">fclose</span>(<span class="variable">$this</span>-&gt;socket);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样服务器代码可以写得更加清晰了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">server</span>(<span class="params"><span class="variable">$port</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;Starting server at port <span class="subst">$port</span>...\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$socket</span> = @<span class="title function_ invoke__">stream_socket_server</span>(<span class="string">&quot;tcp://localhost:<span class="subst">$port</span>&quot;</span>, <span class="variable">$errNo</span>, <span class="variable">$errStr</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable">$socket</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="variable">$errStr</span>, <span class="variable">$errNo</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="title function_ invoke__">stream_set_blocking</span>(<span class="variable">$socket</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$socket</span> = <span class="keyword">new</span> <span class="title class_">CoSocket</span>(<span class="variable">$socket</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">newTask</span>(</span><br><span class="line">      <span class="title function_ invoke__">handleClient</span>(<span class="keyword">yield</span> <span class="variable">$socket</span>-&gt;<span class="title function_ invoke__">accept</span>())</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClient</span>(<span class="params"><span class="variable">$socket</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$data</span> = (<span class="keyword">yield</span> <span class="variable">$socket</span>-&gt;<span class="title function_ invoke__">read</span>(<span class="number">8192</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$msg</span> = <span class="string">&quot;Received following request:\n\n<span class="subst">$data</span>&quot;</span>;</span><br><span class="line">  <span class="variable">$msgLength</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$msg</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="variable">$response</span> = <span class="string">&lt;&lt;&lt;RES</span></span><br><span class="line"><span class="string">HTTP/1.1 200 OK\r</span></span><br><span class="line"><span class="string">Content-Type: text/plain\r</span></span><br><span class="line"><span class="string">Content-Length: <span class="subst">$msgLength</span>\r</span></span><br><span class="line"><span class="string">Connection: close\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string"><span class="subst">$msg</span></span></span><br><span class="line"><span class="string">RES</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">yield</span> <span class="variable">$socket</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$response</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable">$socket</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>作为一名 NB 的程序员，你一定已经注意到了，上面的例子都缺少错误处理机制。差不多 socket 的每一个操作都可能失败并造成错误的。我显然做了这些事，不过错误处理实在是太无聊（ socket 的更是如此！），而且很容易就使得代码量成倍地增长。</p>
<p>不过我还是愿意分享一下协程的一般错误处理方式：协程提供了使用 <code>throw()</code> 方法在它们内部抛出异常的能力。</p>
<p><code>throw()</code> 方法接受一个异常实例，并在协程的当前中断点抛出。考虑以下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;Foo\n&quot;</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Exception: <span class="subst">&#123;$e-&gt;getMessage()&#125;</span>\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;Bar\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$gen</span> = <span class="title function_ invoke__">gen</span>();</span><br><span class="line"><span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">rewind</span>(); <span class="comment">// 输出 &quot;Foo&quot;</span></span><br><span class="line"><span class="variable">$gen</span>-&gt;<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;Test&#x27;</span>)); <span class="comment">// 输出 &quot;Exception: Test&quot; 和 &quot;Bar&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于我们的目的来说这样很 NB ，因为我们可以在系统调用和子协程中抛出异常了。对于系统调用来说 <code>Scheduler::run()</code> 方法需要一些小小的调整：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$retval</span> <span class="keyword">instanceof</span> SystemCall) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable">$retval</span>(<span class="variable">$task</span>, <span class="variable language_">$this</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">setException</span>(<span class="variable">$e</span>);</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">schedule</span>(<span class="variable">$task</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Task</code> 类也需要处理 <code>throw</code> 调用的情况了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$exception</span> = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setException</span>(<span class="params"><span class="variable">$exception</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;exception = <span class="variable">$exception</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;beforeFirstYield) &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;beforeFirstYield = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;coroutine-&gt;<span class="title function_ invoke__">current</span>();</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (<span class="variable language_">$this</span>-&gt;exception) &#123;</span><br><span class="line">      <span class="variable">$retval</span> = <span class="variable language_">$this</span>-&gt;coroutine-&gt;<span class="keyword">throw</span>(<span class="variable language_">$this</span>-&gt;exception);</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;exception = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable">$retval</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable">$retval</span> = <span class="variable language_">$this</span>-&gt;coroutine-&gt;<span class="title function_ invoke__">send</span>(<span class="variable">$this</span>-&gt;sendValue);</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;sendValue = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable">$retval</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>走一个：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_ invoke__">killTask</span>(<span class="number">500</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Tried to kill task 500 but failed: &#x27;</span>, <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>(), <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可惜这还不能正常工作，因为 <code>stackedCoroutine</code> 函数还没有正确地处理异常情况。需要修改一下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackedCoroutine</span>(<span class="params"><span class="built_in">Generator</span> <span class="variable">$gen</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$stack</span> = <span class="keyword">new</span> <span class="built_in">SplStack</span>;</span><br><span class="line">  <span class="variable">$exception</span> = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$exception</span>) &#123;</span><br><span class="line">        <span class="variable">$gen</span>-&gt;<span class="keyword">throw</span>(<span class="variable">$exception</span>);</span><br><span class="line">        <span class="variable">$exception</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="variable">$value</span> = <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">current</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$value</span> <span class="keyword">instanceof</span> <span class="built_in">Generator</span>) &#123;</span><br><span class="line">        <span class="variable">$stack</span>-&gt;<span class="title function_ invoke__">push</span>(<span class="variable">$gen</span>);</span><br><span class="line">        <span class="variable">$gen</span> = <span class="variable">$value</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="variable">$isReturnValue</span> = <span class="variable">$value</span> <span class="keyword">instanceof</span> CoroutineReturnValue;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">valid</span>() || <span class="variable">$isReturnValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$stack</span>-&gt;<span class="title function_ invoke__">isEmpty</span>()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$gen</span> = <span class="variable">$stack</span>-&gt;<span class="title function_ invoke__">pop</span>();</span><br><span class="line">        <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="variable">$isReturnValue</span> ? <span class="variable">$value</span>-&gt;<span class="title function_ invoke__">getValue</span>() : <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable">$sendValue</span> = (<span class="keyword">yield</span> <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">key</span>() =&gt; <span class="variable">$value</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">        <span class="variable">$gen</span>-&gt;<span class="keyword">throw</span>(<span class="variable">$e</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="variable">$gen</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="variable">$sendValue</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$stack</span>-&gt;<span class="title function_ invoke__">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="variable">$e</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="variable">$gen</span> = <span class="variable">$stack</span>-&gt;<span class="title function_ invoke__">pop</span>();</span><br><span class="line">      <span class="variable">$exception</span> = <span class="variable">$e</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们创建了一个多任务协作的任务调度器，同时具备“系统调用”、执行异步 IO 操作和错误处理的能力。最酷的一点是这些代码看起来是完全同步的，尽管它执行了许多异步操作。如果你想从某个 socket 中读取数据，你既不必传递回调函数，也不必注册事件监听器。取而代之的你只需要写一句 <code>yield $socket-&gt;read()</code> 。与你常写的代码基本一致，仅仅只用在前面加一个 <code>yield</code> 。</p>
<p>当我第一次听说这些概念时，我发现这个概念真的 NB ，并且直接促使我在 PHP 中也实现这些特性。同时我发现协程真的容易让人担心。协程的使用，让完美的代码和糟糕的代码之间仅有一线之隔。对我而言，很难评价像上文一样的方式去写异步代码是否真的有益。</p>
<p>无论如何，我都认为这是一个有趣的话题，希望你也感兴趣。期待您的评论 : - )</p>
<blockquote>
<p>翻译自：<a target="_blank" rel="noopener" href="https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines (in PHP!)</a></p>
<p>原文作者：<a target="_blank" rel="noopener" href="https://nikic.github.io/aboutMe.html">Nikita Popov</a></p>
</blockquote>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/03/understand-js-closure/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          搞不明白的 Javascript 闭包
        
      </div>
    </a>
  
  
    <a href="/2016/06/28/Laravel-5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Laravel 5 流程简析</div>
    </a>
  
</nav>

  
</article>

<script type='text/javascript'>window.notIndexPage = true;</script>


<section id="comments">
  <div id="disqus_thread">
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'imzvz'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>
    Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
  </div>
</section>
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>
      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	Linked with:&nbsp;&nbsp;&nbsp; 
	<a href="http://mritd.me" target="_blank">mritd.me</a>&nbsp;&nbsp;&nbsp;
	<a href="https://www.mghio.cn" target="_blank">mghio's blog</a>&nbsp;&nbsp;&nbsp;
	<a href="https://sillydong.com" target="_blank">傻东の学习笔记</a>&nbsp;&nbsp;&nbsp;
	</div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
</nav>
    
<script>
  var disqus_shortname = 'imzvz';
  
  var disqus_url = 'http://log.zvz.im/2016/07/01/PHP-Coroutine/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>

<script>
  if(window.notIndexPage)
  $(function(){
    $.get('//manage.zvz.im/api/posts/adv', function(res) {
      if(res.data.length) {
        $.each(res.data, function(idx, adv) {
          if(idx == 0) {
            if($('h2:first').length > 0) {
              $(adv).insertBefore('h2:first');
              return;
            }
          }
          $(adv).insertAfter('.article-inner');
        });
      }
    });
  });
</script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/require.min.js"></script>


<script src="/js/script.js"></script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({{ JSON.stringify(config) }});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="{{ src }}">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>