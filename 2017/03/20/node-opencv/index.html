<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>OpenCV 入门：Node.js 计算机视觉处理 | Z - Computer &amp; Programming Technology</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google-adsense-account" content="ca-pub-8768699638326268">
  <meta name="description" content="在这篇 OpenCV 入门文章中，我将会向大家展示如何使用 Node.js 进行计算机视觉处理。并且结合实例讲解使用 OpenCV 这个开源库进行图像处理的基础方法。 目前，我正在完成我的硕士论文，其中使用到了 React Native，神经网络，和 OpenCV 计算机视觉库。请允许我向你们展示一些我在使用 OpenCV 过程中学习到的一些东西。  计算机视觉是计算机科学中的一个领域，主要专注于">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV 入门：Node.js 计算机视觉处理">
<meta property="og:url" content="http://zvz.im/2017/03/20/node-opencv/index.html">
<meta property="og:site_name" content="Z - Computer &amp; Programming Technology">
<meta property="og:description" content="在这篇 OpenCV 入门文章中，我将会向大家展示如何使用 Node.js 进行计算机视觉处理。并且结合实例讲解使用 OpenCV 这个开源库进行图像处理的基础方法。 目前，我正在完成我的硕士论文，其中使用到了 React Native，神经网络，和 OpenCV 计算机视觉库。请允许我向你们展示一些我在使用 OpenCV 过程中学习到的一些东西。  计算机视觉是计算机科学中的一个领域，主要专注于">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/c1afacfcbce536d3.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/470560edbd5675be.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/2d1840e7761522b8.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/c2316008cb739a25.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/97dd7ea051bb7cbb.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/e4af008c72801d71.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/6c51dfe0d4de36c5.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/c200eeb23703b2c0.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/470560edbd5675be.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/07508d8ffe2c236e.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/246848b1793b0f98.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/df9ace1263c0476b.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/88e343ab79695efc.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/4f73351216c0607f.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/cb6d4e52603a38f1.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/36f55bf3133a2346.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/a65f66ec8a92d4c0.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/69ffacfce4d67078.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/4010207470c71e31.png">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/0f82295326f2c5fd.png">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/2b7a99d9ea52c2d6.png">
<meta property="article:published_time" content="2017-03-20T19:21:42.000Z">
<meta property="article:modified_time" content="2025-07-04T09:35:17.313Z">
<meta property="article:author" content="darluc">
<meta property="article:tag" content="Nodejs">
<meta property="article:tag" content="opencv">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.zvz.im/imgs/2019/06/c1afacfcbce536d3.jpg">
  
    <link rel="alternative" href="/atom.xml" title="Z - Computer &amp; Programming Technology" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.geekzu.org/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8NRBEZPWYN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8NRBEZPWYN');
</script>


  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8768699638326268"
     crossorigin="anonymous"></script>
<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-node-opencv" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      OpenCV 入门：Node.js 计算机视觉处理
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/03/20/node-opencv/" class="article-date">
  <time datetime="2017-03-20T19:21:42.000Z" itemprop="datePublished">2017-03-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tags/Nodejs/">Nodejs</a> <a class="article-category-link" href="/tags/opencv/">opencv</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在这篇 OpenCV 入门文章中，我将会向大家展示如何使用 Node.js 进行计算机视觉处理。并且结合实例讲解使用 OpenCV 这个开源库进行图像处理的基础方法。</p>
<p>目前，我正在完成我的硕士论文，其中使用到了 React Native，神经网络，和 OpenCV 计算机视觉库。请允许我向你们展示一些我在使用 OpenCV 过程中学习到的一些东西。</p>
<blockquote>
<p>计算机视觉是计算机科学中的一个领域，主要专注于使用不同的算法从图像和视频中获取数据。</p>
</blockquote>
<p>计算机视觉在许多领域得到了广泛地应用，例如安全摄像头的运动跟踪，控制车辆进行自动驾驶，从图片或视频中识别或搜索对象。</p>
<p>要实现计算机视觉算法是一件非常繁复的工作，不过幸好有 <a target="_blank" rel="noopener" href="http://opencv.org/">OpenCV</a> 这个非常好的开源库，此库起源于 1999 年，并一直发展到现在。</p>
<p>OpenCV 官方支持 C，C ++，Python 和 Java。幸运的是，由 Peter Braden 领导的一群 Javascript 程序员开发了一个 Javascript 的 OpenCV 接口库，名为 <a target="_blank" rel="noopener" href="https://github.com/peterbraden/node-opencv">node-opencv</a>。</p>
<p>利用该接口库，我们可以实现用于图像分析的 Node.js 应用。此库目前还没有实现所有的 OpenCV 特性 - 特别是 OpenCV 3 的一些特性 - 不过已经基本够用了。<br><span id="more"></span></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要在 Node.js 中使用 OpenCV 库，你得先进行全局安装。在 MacOS 上，你可以通过 <a target="_blank" rel="noopener" href="http://brew.sh/">Homebrew</a> 来安装。在这篇文章中我安装并使用的是 OpenCV 的 2.4 版本。</p>
<blockquote>
<p>译者注：由于译者实际使用的是 OpenCV 3.2.0 版本，故在边缘侦测部分的代码相对于原文有所修改。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap homebrew/science</span><br><span class="line">brew install opencv</span><br></pre></td></tr></table></figure>
<p>如果你使用的是其它的操作系统，这里有 <a target="_blank" rel="noopener" href="http://docs.opencv.org/2.4/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation">Linux</a> 和 <a target="_blank" rel="noopener" href="http://docs.opencv.org/2.4/doc/tutorials/introduction/windows_install/windows_install.html#windows-installation">Windows</a> 版本的教程。在成功安装之后，我们就可以在 Node.js 项目中安装 node-opencv 了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save opencv</span><br></pre></td></tr></table></figure>
<p>有时安装会失败（它是开源项目，还没有到达最终完成的阶段），不过你应该可以在<a target="_blank" rel="noopener" href="https://github.com/peterbraden/node-opencv">该项目的 GitHub 页面</a>上找到对应的解决办法。</p>
<h2 id="OpenCV-基础"><a href="#OpenCV-基础" class="headerlink" title="OpenCV 基础"></a>OpenCV 基础</h2><h3 id="加载及保存图片-矩阵"><a href="#加载及保存图片-矩阵" class="headerlink" title="加载及保存图片 + 矩阵"></a>加载及保存图片 + 矩阵</h3><p>OpenCV 的最基本功能是加载和保存图像。你可以通过下面的方法调用这些功能：<strong>cv#readImage()</strong> 和 <strong>Maritx#save()</strong>；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cv = <span class="built_in">require</span>(<span class="string">&#x27;opencv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cv.<span class="title function_">readImage</span>(<span class="string">&#x27;./img/myImage.jpg&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, img</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> width = im.<span class="title function_">width</span>();</span><br><span class="line">  <span class="keyword">const</span> height = im.<span class="title function_">height</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (width &lt; <span class="number">1</span> || height &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Image has no size&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// do some cool stuff with img</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save img</span></span><br><span class="line">  img.<span class="title function_">save</span>(<span class="string">&#x27;./img/myNewImage.jpg&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/c1afacfcbce536d3.jpg" alt=""></p>
<p>承载加载图片数据的对象，是 OpenCV 使用的一个基本数据结构 - 矩阵。所有载入和生成的图像都是用矩阵来描述的，矩阵中的每一个元素都对应图像的一个像素。矩阵的大小由载入图像的大小决定。在 Node.js 中你可以使用特定参数调用 new Matrix() 构造方法来生成一个矩阵。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> cv.<span class="title class_">Matrix</span>(rows, cols);</span><br><span class="line"><span class="keyword">new</span> cv.<span class="title class_">Matrix</span>(rows, cols, type, fillValue);</span><br></pre></td></tr></table></figure>
<h3 id="修改图像"><a href="#修改图像" class="headerlink" title="修改图像"></a>修改图像</h3><p>变换图像颜色是一个基础方法。例如，我们可以调用 <strong>Matrix#convertGrayscale()</strong> 得到一个灰度图片。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img.<span class="title function_">convertGrayScale</span>();</span><br><span class="line">img.<span class="title function_">save</span>(<span class="string">&#x27;./img/myGrayscaleImg.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/470560edbd5675be.jpg" alt=""></p>
<p>在进行边缘探测时经常会用到这个方法。</p>
<p>我们可以使用 <strong>Matrix#convertHSVscale()</strong> 方法将图像转换为 HSV 圆柱坐标表示（HSV cylindrical-coordinate representation ）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img.<span class="title function_">convertHSVscale</span>();</span><br><span class="line">img.<span class="title function_">save</span>(<span class="string">&#x27;./img/myHSVscaleImg.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/2d1840e7761522b8.jpg" alt=""></p>
<p>我们可以使用 <strong>Matrix#crop(x, y, width, height)</strong> 方法来裁剪图片，并指定其中的参数。</p>
<p>这个方法并不会改变当前的图像，而是返回一个全新的图像。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> croppedImg = img.<span class="title function_">crop</span>(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">croppedImg.<span class="title function_">save</span>(<span class="string">&#x27;./img/croppedImg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们想要将图像对象赋值给另一个变量，可以使用 <strong>Matrix#copy()</strong> 方法返回一个新的图片对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newImg = img.<span class="title function_">copy</span>();</span><br></pre></td></tr></table></figure>
<p>这样，我们可以用一些基础的 Matrix 方法进行工作了。我们还能找到各种模糊和滤镜方法来进行图片编辑。你可以在 GitHub 项目里的 <a target="_blank" rel="noopener" href="https://github.com/peterbraden/node-opencv/blob/976788c411cdff098247c40a17082c0ddaeaaadd/src/Matrix.cc">Matrix.cc</a> 文件中找到 Matrix 对象实现的所有方法。</p>
<h3 id="腐蚀和膨胀"><a href="#腐蚀和膨胀" class="headerlink" title="腐蚀和膨胀"></a>腐蚀和膨胀</h3><p>腐蚀和膨胀是数学形态学（ mathematical morphology ）的基本方法。我将结合下面的图像修改操作来解释它们是如何工作的。（译者注：具体数学定义可<a target="_blank" rel="noopener" href="http://media.cs.tsinghua.edu.cn/~ahz/digitalimageprocess/chapter08/chapt08_ahz.htm">参考此文</a>）</p>
<p><img src="https://img.zvz.im/imgs/2019/06/c2316008cb739a25.jpg" alt=""></p>
<p>二进制图像 A 通过结构元素 B 的膨胀定义如下</p>
<p><img src="https://img.zvz.im/imgs/2019/06/97dd7ea051bb7cbb.jpg" alt=""></p>
<p>OpenCV 有一个 <strong>Matrix#dilate(iterations, structEl)</strong> 方法，其中的 <strong>iterations</strong> 参数指定膨胀的量，<strong>structEl</strong> 参数是用于膨胀的结构元素（默认为 3X3）。</p>
<p>我们可以用此参数调用膨胀方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.<span class="title function_">dilate</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>OpenCV 调用膨胀方法时如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">dilate</span>(self-&gt;mat, self-&gt;mat, sturctEl, cv::<span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>调用过此方法后，我们可以得到如下修改过的图像。</p>
<p><img src="https://img.zvz.im/imgs/2019/06/e4af008c72801d71.jpg" alt=""></p>
<p>二进制图像 A 通过结构元素 B 的腐蚀定义如下</p>
<p><img src="https://img.zvz.im/imgs/2019/06/6c51dfe0d4de36c5.jpg" alt=""></p>
<p>在 OpenCV 中，我们可以调用 <strong>Martix#erode(iterations, structEl)</strong> 方法，和前面的膨胀方法相似。</p>
<p>我们可以这样调用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.<span class="title function_">erode</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>同样我们可以得到一个腐蚀过的图像。</p>
<p><img src="https://img.zvz.im/imgs/2019/06/c200eeb23703b2c0.jpg" alt=""></p>
<h3 id="边缘侦测"><a href="#边缘侦测" class="headerlink" title="边缘侦测"></a>边缘侦测</h3><p>关于边缘侦测，我们可以使用「坎尼边缘探测算法」。该算法起源于 1986 年，并且一个非常流行，被称作「最佳探测器」。算法规定了边缘侦测中三个重要的标准，列举如下：</p>
<ol>
<li>边缘侦测要保证低错误率；</li>
<li>良好的边缘定位 - 探测到的边缘和实际边缘像素差必须最小；</li>
<li>图像的边缘只能被标记一次；</li>
</ol>
<p>在使用「坎尼边缘探测算法」前，我们可以先将图像转为灰度格式，通常这样做可以让我们获得更好的结果。接下来，我们可以通过高斯模糊滤镜消除图像上的噪点，它需要一个向量作为高斯核大小的参数（which receives a parameter as a field - Gaussian kernel size）。再调用这两个方法处理过后，我们可以在坎尼边缘侦测时获得更好更准确的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im.<span class="title function_">convertGrayscale</span>();</span><br><span class="line">im.<span class="title function_">gaussianBlur</span>([<span class="number">3</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/470560edbd5675be.jpg" alt=""></p>
<p>图像现已准备就绪，可以开始使用坎尼边缘侦测算法了。此算法接收两个参数：<strong>lowThreshold</strong> 和 <strong>highThreshold</strong> 。</p>
<p>这两个阈值帮你将所有像素划分为三组。</p>
<ul>
<li>如果梯度像素（ gradient pixel ）的值比 <strong>highThreshold</strong> 高，则该像素被标记为强边缘像素（ strong edge pixels ）。</li>
<li>如果梯度像素的值介于高低阈值间，则该像素被标记为弱边缘像素（ weak edge pixels ）。</li>
<li>如果梯度像素的值比低阈值还低，那这些像素就完全被抑制。</li>
</ul>
<p>并不存在一个针对所有图像都有效的通用阈值设定。<strong>你需要针对每个图像设定合适的阈值</strong>。不过存在一些方法可以预测合适的阈值，但是我不会在此文中具体说明。</p>
<p>在调用 Canny Edge 方法后，我们还会调用一次膨胀方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lowThresh = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> highThresh = <span class="number">150</span>;</span><br><span class="line"><span class="keyword">const</span> iterations = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">img.<span class="title function_">canny</span>(lowThresh, highThresh);</span><br><span class="line">img.<span class="title function_">dilate</span>(iterations);</span><br></pre></td></tr></table></figure>
<p>经过以上步骤，我们就有了一张被分析过的图像。从这张图像上，我们可以选出所有的轮廓线，只需调用 <strong>Matrix#findContours()</strong> 方法，再将其写入到一个新的图像中。</p>
<blockquote>
<p>译者注：此处代码根据 <a target="_blank" rel="noopener" href="https://github.com/peterbraden/node-opencv/blob/master/examples/contours.js">https://github.com/peterbraden/node-opencv/blob/master/examples/contours.js</a> 进行了部分调整。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">WHITE</span> = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>];</span><br><span class="line"><span class="keyword">let</span> contours = img.<span class="title function_">findContours</span>();</span><br><span class="line"><span class="keyword">var</span> all = <span class="keyword">new</span> cv.<span class="title class_">Matrix</span>(height, width);</span><br><span class="line">all.<span class="title function_">drawAllContours</span>(contours, <span class="variable constant_">WHITE</span>);</span><br><span class="line"></span><br><span class="line">all.<span class="title function_">save</span>(<span class="string">&#x27;./img/allContoursImg.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/07508d8ffe2c236e.jpg" alt=""></p>
<p>膨胀过后的图像</p>
<p><img src="https://img.zvz.im/imgs/2019/06/246848b1793b0f98.jpg" alt=""></p>
<p>未进行膨胀的图像</p>
<p>在图片中我们可以看到所有通过坎尼边缘侦测到的轮廓。</p>
<p>如果我们只要选出最大的轮廓，可以使用下面的代码：循环每个轮廓，找出最大的那个。可以使用 <strong>Matrix#drawContour</strong> 方法将其画出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">GREEN</span> = [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> contours = img.<span class="title function_">contours</span>();</span><br><span class="line"><span class="keyword">let</span> largestContourImg;</span><br><span class="line"><span class="keyword">let</span> largestArea = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> largestAreaIndex;</span><br><span class="line"></span><br><span class="line">largestContourImg = <span class="keyword">new</span> cv.<span class="title class_">Matrix</span>(height, width);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; contours.<span class="title function_">size</span>(); i ++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (contours.<span class="title function_">area</span>(i) &gt; largestArea) &#123;</span><br><span class="line">    largestArea = contours.<span class="title function_">area</span>(i);</span><br><span class="line">    largestAreaIndex = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lineType = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> maxLevel = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> thickness = <span class="number">1</span>;</span><br><span class="line">largestContourImg.<span class="title function_">drawContour</span>(contours, largestAreaIndex, <span class="variable constant_">GREEN</span>, thickness, lineType, maxLevel, [<span class="number">0</span>, <span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/df9ace1263c0476b.jpg" alt=""></p>
<p>如果想要多一些轮廓线，比如大于特定值的所有轮廓，我们只需要将 <strong>Matrix#drawContour()</strong> 方法挪到 for 循环中同时更改一下 <strong>if</strong> 条件即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">GREEN</span> = [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> lineType = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> maxLevel = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> thickness = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> contours = img.<span class="title function_">contours</span>();</span><br><span class="line"><span class="keyword">let</span> largestContourImg;</span><br><span class="line"><span class="keyword">let</span> largestArea = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; contours.<span class="title function_">size</span>(); i ++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (contours.<span class="title function_">area</span>(i) &gt; largestArea) &#123;</span><br><span class="line">    largestContourImg.<span class="title function_">drawContour</span>(contours, i, <span class="variable constant_">GREEN</span>, thickness, lineType, maxLevel, [<span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/88e343ab79695efc.jpg" alt=""></p>
<h3 id="多边形近似"><a href="#多边形近似" class="headerlink" title="多边形近似"></a>多边形近似</h3><p>多边形近似（ Polygon approximation ）可以用来做许多事情。最简单的就是使用 <strong>Contours#boundingRect(index)</strong> 方法在对象周围画上一个矩形框。此方法是属于 Contours 对象的。对图像进行坎尼边缘侦测后，调用 <strong>Martix#findContours()</strong> 方法就可以得到 Contours 对象（上一个例子中我们讲过的）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bound = contours.<span class="title function_">boundingRect</span>(largestAreaIndex);</span><br><span class="line">largestContourImg.<span class="title function_">rectangle</span>([bound.<span class="property">x</span>, bound.<span class="property">y</span>], [bound.<span class="property">width</span>, bound.<span class="property">height</span>], <span class="variable constant_">WHITE</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/4f73351216c0607f.jpg" alt=""></p>
<p>第二种使用多边形近似的方法是通过调用 <strong>Contours#approxPolyDP()</strong> 方法获得指定精确的多边形。通过调用 <strong>Contours#cornerCount(index)</strong> 方法，可以获取到多边形顶角的数量。下面附上了两种使用不同级别精度获取到的图像。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> poly;</span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">RED</span> = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>];</span><br><span class="line"><span class="keyword">let</span> arcLength = contours.<span class="title function_">arcLength</span>(largestAreaIndex, <span class="literal">true</span>);</span><br><span class="line">contours.<span class="title function_">approxPolyDP</span>(largestAreaIndex, arcLength * <span class="number">0.05</span>, <span class="literal">true</span>);</span><br><span class="line">poly.<span class="title function_">drawContour</span>(contours, largestAreaIndex, <span class="variable constant_">RED</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// number of corners</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(contours.<span class="title function_">cornerCount</span>(largestAreaIndex));</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/cb6d4e52603a38f1.jpg" alt=""></p>
<p><img src="https://img.zvz.im/imgs/2019/06/36f55bf3133a2346.jpg" alt=""></p>
<p>使用 <strong>Contours#minAreaRect()</strong> 方法获取一个旋转过的面积最小的近似矩形也很有意思。</p>
<p>在项目中我使用它来判断一个特定的物件旋转到正确位置后的角度。下面一个例子，我们会对 <strong>largestContourImg</strong> 增加一个旋转过的矩形，并且打印出该矩形的旋转角度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rect = contours.<span class="title function_">minAreaRect</span>(largestAreaIndex);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">  largestContourImg.<span class="title function_">line</span>([rect.<span class="property">points</span>[i].<span class="property">x</span>, rect.<span class="property">points</span>[i].<span class="property">y</span>], [rect.<span class="property">points</span>[(i+<span class="number">1</span>)%<span class="number">4</span>].<span class="property">x</span>, rect.<span class="property">points</span>[(i+<span class="number">1</span>)%<span class="number">4</span>].<span class="property">y</span>], <span class="variable constant_">RED</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// angle of polygon</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rect.<span class="property">angle</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/a65f66ec8a92d4c0.jpg" alt=""></p>
<h3 id="无裁剪图片旋转"><a href="#无裁剪图片旋转" class="headerlink" title="无裁剪图片旋转"></a>无裁剪图片旋转</h3><p>有一件事情是我需要解决，而 OpenCV 没有实现的。这件事就是旋转图像的同时，保证图像不会被裁剪掉。旋转图像是很简单的。</p>
<blockquote>
<p>译者注：译者使用 opencv 3.2.0 版本进行测试，发现 opencv 的旋转功能不会发现本文描述的图片被裁剪的状况。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.<span class="title function_">rotate</span>(<span class="number">90</span>);</span><br></pre></td></tr></table></figure>
<p>只是我们会得到如下的结果：</p>
<p><img src="https://img.zvz.im/imgs/2019/06/69ffacfce4d67078.jpg" alt=""></p>
<p><strong>怎样才能做到既旋转了图片又不会被裁剪呢？</strong>在旋转之前，我们先生成一个 8 位 3 通道的矩阵 <strong>bgImg</strong> ，其边长等于原图对角线的长度。</p>
<p>然后，我们计算出图像在新的 <strong>bgImg</strong> 矩阵中摆放的位置，使其能够被完整放入 <strong>bgImg</strong> 中。在 <strong>bgImg</strong> 中，我们使用计算出来的值调用 <strong>Matrix#rotate(angle)</strong> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rect = contours.<span class="title function_">minAreaRect</span>(largestAreaIndex);</span><br><span class="line"><span class="keyword">let</span> diagonal = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(im.<span class="title function_">size</span>()[<span class="number">1</span>], <span class="number">2</span>) + <span class="title class_">Math</span>.<span class="title function_">pow</span>(im.<span class="title function_">size</span>()[<span class="number">0</span>], <span class="number">2</span>)));</span><br><span class="line"><span class="keyword">let</span> bgImg = <span class="keyword">new</span> cv.<span class="title class_">Matrix</span>(diagonal, diagonal, cv.<span class="property">Constants</span>.<span class="property">CV_8UC3</span>, [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]);</span><br><span class="line"><span class="keyword">let</span> offsetX = (diagonal - im.<span class="title function_">size</span>()[<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> offsetY = (diagonal - im.<span class="title function_">size</span>()[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">IMG_ORIGINAL</span>.<span class="title function_">copyTo</span>(bgImg, offsetX, offsetY);</span><br><span class="line">bgImg.<span class="title function_">rotate</span>(rect.<span class="property">angle</span> + <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">bgImg.<span class="title function_">save</span>(<span class="string">&#x27;./img/rotatedImg.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/4010207470c71e31.png" alt=""></p>
<p>然后，我们可以对新的旋转图片使用坎尼边缘侦测方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">GREEN</span> = [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>];;</span><br><span class="line"><span class="keyword">let</span> rotatedContour = <span class="keyword">new</span> cv.<span class="title class_">Matrix</span>(diagonal, diagonal);</span><br><span class="line">bgImg.<span class="title function_">canny</span>(lowThresh, highThresh);</span><br><span class="line">bgImg.<span class="title function_">dilate</span>(nIters);</span><br><span class="line"><span class="keyword">let</span> contours = bgImg.<span class="title function_">findContours</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; contours.<span class="title function_">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (contours.<span class="title function_">area</span>(i) &gt; largestArea) &#123;</span><br><span class="line">    largestArea = contours.<span class="title function_">area</span>(i);</span><br><span class="line">    largestAreaIndex = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rotatedContour.<span class="title function_">drawContour</span>(contours, largestAreaIndex, <span class="variable constant_">GREEN</span>, thickness, lineType);</span><br><span class="line">rotatedContour.<span class="title function_">save</span>(<span class="string">&#x27;./img/rotatedImgContour.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/0f82295326f2c5fd.png" alt=""></p>
<p>还有许多操作图片的方法。比如，很实用的去除背景功能 - 不过本文就暂不做介绍了。</p>
<h3 id="物体侦测"><a href="#物体侦测" class="headerlink" title="物体侦测"></a>物体侦测</h3><p>实际上我工作时，我的程序会处理植物图像，并不会使用人脸，汽车或其它物件的识别器。</p>
<blockquote>
<p>即便如此，我还是决定在本文中提一下面部识别，因为它更能够提现 OpenCV 的强大技术。</p>
</blockquote>
<p>对于载入的图像，我们可以使用 <strong>Matrix#detectObject()</strong> 方法，该方法接受一个「级联分类器」（ cascade classifier ）路径作为参数。<strong>OpenCV 自带一些预先训练好的分类器，可以用来侦测数字，面部，眼睛，耳朵，猫咪等等。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cv.<span class="title function_">readImage</span>(<span class="string">&#x27;./img/face.jpg&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, im</span>)&#123;  </span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">if</span> (im.<span class="title function_">width</span>() &lt; <span class="number">1</span> || im.<span class="title function_">height</span>() &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Image has no size&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  im.<span class="title function_">detectObject</span>(<span class="string">&#x27;./data/haarcascade_frontalface_alt2.xml&#x27;</span>, &#123;&#125;, <span class="keyword">function</span>(<span class="params">err, faces</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; faces.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> face = faces[i];</span><br><span class="line">      im.<span class="title function_">ellipse</span>(face.<span class="property">x</span> + face.<span class="property">width</span> / <span class="number">2</span>, face.<span class="property">y</span> + face.<span class="property">height</span> / <span class="number">2</span>, face.<span class="property">width</span> / <span class="number">2</span>, face.<span class="property">height</span> / <span class="number">2</span>, [<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>], <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    im.<span class="title function_">save</span>(<span class="string">&#x27;./img/face-detection.jpg&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Image saved.&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.zvz.im/imgs/2019/06/2b7a99d9ea52c2d6.png" alt=""></p>
<blockquote>
<p>译者注：译者找了个照片试了一下，发现会有误认的情况。。。不知道是否有方法提高准确度。</p>
</blockquote>
<p><strong>本文中，我讲了一些 OpenCV 库在 Node.js 中的有趣特性。</strong>虽然 OpenCV 没有官方的 Node.js 接口挺令人失望的，还好有这个 node-opencv 库，尽管有些功能没有实现，API 也不是很稳定，但是瑕不掩瑜。</p>
<p>如果你想要在工作中使用此类库，你应当研究一下 <a target="_blank" rel="noopener" href="https://github.com/peterbraden/node-opencv">node-opencv</a> 代码库中的 .cc 文件，因为此类库目前还没有一个完整的文档。</p>
<p>直接去读代码当然是最好的，我也很喜欢这样做；但是类库中有些返回值与 OpenCV 官方不一致和区别的地方，还是让我不那么爽。<strong>希望这个类库能够快快发展，我也会尽我所能贡献一些代码。</strong></p>
<blockquote>
<p>译者注：修改了边缘侦测部分的代码后，译者发现类库 API 与官方不一致的问题有所改善。</p>
</blockquote>
<blockquote>
<p>翻译自：<a target="_blank" rel="noopener" href="https://community.risingstack.com/opencv-tutorial-computer-vision-with-node-js/">OpenCV tutorial: Computer vision with Node.js</a></p>
</blockquote>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/23/why-curry-helps/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          为什么柯里化有用
        
      </div>
    </a>
  
  
    <a href="/2016/12/30/utf8-in-javascript/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Javascript 中的 UTF-8</div>
    </a>
  
</nav>

  
</article>

<script type='text/javascript'>window.notIndexPage = true;</script>


<section id="comments">
  <div id="disqus_thread">
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'imzvz'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>
    Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
  </div>
</section>
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>
      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	Linked with:&nbsp;&nbsp;&nbsp; 
	<a href="http://mritd.me" target="_blank">mritd.me</a>&nbsp;&nbsp;&nbsp;
	<a href="https://www.mghio.cn" target="_blank">mghio's blog</a>&nbsp;&nbsp;&nbsp;
	<a href="https://sillydong.com" target="_blank">傻东の学习笔记</a>&nbsp;&nbsp;&nbsp;
	</div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
</nav>
    
<script>
  var disqus_shortname = 'imzvz';
  
  var disqus_url = 'http://zvz.im/2017/03/20/node-opencv/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>

<script>
  if(window.notIndexPage)
  $(function(){
    $.get('//manage.zvz.im/api/posts/adv', function(res) {
      if(res.data.length) {
        $.each(res.data, function(idx, adv) {
          if(idx == 0) {
            if($('h2:first').length > 0) {
              $(adv).insertBefore('h2:first');
              return;
            }
          }
          $(adv).insertAfter('.article-inner');
        });
      }
    });
  });
</script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/require.min.js"></script>


<script src="/js/script.js"></script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({{ JSON.stringify(config) }});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="{{ src }}">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>