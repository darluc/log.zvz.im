<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>百万请求一分钟，Golang 轻松来搞定 | Z - Computer &amp; Programming Technology</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google-adsense-account" content="ca-pub-8768699638326268">
  <meta name="description" content="我在反广告、杀病毒、检木马等行业的不同软件公司里已经工作 15 年以上了，非常了解这类系统软件因每天处理海量数据而导致的复杂性。 目前我作为 smsjunk.com 的 CEO 和 KnowBe4 的主架构师，在这两个网络安全领域的公司里工作。">
<meta property="og:type" content="article">
<meta property="og:title" content="百万请求一分钟，Golang 轻松来搞定">
<meta property="og:url" content="http://zvz.im/2018/02/28/handling-million-requests-with-golang/index.html">
<meta property="og:site_name" content="Z - Computer &amp; Programming Technology">
<meta property="og:description" content="我在反广告、杀病毒、检木马等行业的不同软件公司里已经工作 15 年以上了，非常了解这类系统软件因每天处理海量数据而导致的复杂性。 目前我作为 smsjunk.com 的 CEO 和 KnowBe4 的主架构师，在这两个网络安全领域的公司里工作。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/8cdd2b7f20b4b9fe.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/a7dd8e1bb4446be3.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/d21c1ec060f286f7.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/3c0a7a5f497861ed.jpg">
<meta property="og:image" content="https://img.zvz.im/imgs/2019/06/f1571f323aa5126a.jpg">
<meta property="article:published_time" content="2018-02-28T14:57:54.000Z">
<meta property="article:modified_time" content="2025-07-04T09:35:17.312Z">
<meta property="article:author" content="darluc">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.zvz.im/imgs/2019/06/8cdd2b7f20b4b9fe.jpg">
  
    <link rel="alternative" href="/atom.xml" title="Z - Computer &amp; Programming Technology" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.geekzu.org/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8NRBEZPWYN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8NRBEZPWYN');
</script>


  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8768699638326268"
     crossorigin="anonymous"></script>
<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-handling-million-requests-with-golang" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      百万请求一分钟，Golang 轻松来搞定
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/02/28/handling-million-requests-with-golang/" class="article-date">
  <time datetime="2018-02-28T14:57:54.000Z" itemprop="datePublished">2018-02-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tags/golang/">golang</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://img.zvz.im/imgs/2019/06/8cdd2b7f20b4b9fe.jpg" alt=""></p>
<p>我在反广告、杀病毒、检木马等行业的不同软件公司里已经工作 15 年以上了，非常了解这类系统软件因每天处理海量数据而导致的复杂性。</p>
<p>目前我作为 <a target="_blank" rel="noopener" href="https://smsjunk.com/">smsjunk.com</a> 的 CEO 和 <a target="_blank" rel="noopener" href="http://knowbe4.com/">KnowBe4</a> 的主架构师，在这两个网络安全领域的公司里工作。<br><span id="more"></span><br>有趣的是，在过去的 10 年里，作为软件工程师，我接触到的 web 后端代码大多是用 Ruby on Rails 开发的。请不要误会，我很喜欢 Ruby on Railds 框架，而且我认为它是一套令人称赞的框架，不过时间一长，你就会习惯于使用 ruby 语言的方式思考和设计系统，会忘记利用多线程，并行化，快速执行和小的内存消耗，软件架构本可以如此高效且简单。很多年来，我也是一个 C/C++，Delphi 以及 C# 的使用者，而且我开始认识到使用正确的工具能让事情变得更简单。</p>
<blockquote>
<p>我对互联网上没完没了的语言框架之间的论战并不感冒。因为我相信解决方案的效能及代码可维护性主要倚仗于你的架构能做到多简单。</p>
</blockquote>
<h2 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h2><p>在实现某个遥测分析系统时，我们遇到一个实际问题，要处理来自数百万终端的 POST 请求。其中的 web 请求处理过程会接收到一个 JSON 文档，它包含一个由许多荷载数据组成的集合，我们要把它写到 Amazon S3 存储中，之后我们的 map-reduce 系统就可以对这些数据进行处理。</p>
<p>一般我们会利用如下的组件去创建一个有后台工作层的架构，如：</p>
<ul>
<li>Sidekiq</li>
<li>Resque</li>
<li>DelayedJob</li>
<li>Elasticbeanstalk Worker Tier</li>
<li>RabbitMQ</li>
<li>等等</li>
</ul>
<p>并且建立两个不同的服务集群，一个用作 web 前端接收数据，另一个执行具体的工作，这样我们就能动态调整后台处理工作的能力了。</p>
<p>不过从项目伊始，我们的团队就认为应该用 Go 语言来实现这项工作，因为在讨论过程中我们发现这可能是一个流量巨大的系统。我已经使用 Go 语言快两年了，而且我们已经在工作中用它开发了一些系统，只是还没遇到过负载如此大的系统。</p>
<p>我们从定义一些 web 的 POST 请求载荷数据结构开始，还有一个用于上传到 S3 存储的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PayloadCollection <span class="keyword">struct</span> &#123;</span><br><span class="line">	WindowsVersion  <span class="type">string</span>    <span class="string">`json:&quot;version&quot;`</span></span><br><span class="line">	Token           <span class="type">string</span>    <span class="string">`json:&quot;token&quot;`</span></span><br><span class="line">	Payloads        []Payload <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Payload <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// [redacted]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Payload)</span></span> UploadToS3() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// the storageFolder method ensures that there are no name collision in</span></span><br><span class="line">	<span class="comment">// case we get same timestamp in the key name</span></span><br><span class="line">	storage_path := fmt.Sprintf(<span class="string">&quot;%v/%v&quot;</span>, p.storageFolder, time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	bucket := S3Bucket</span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	encodeErr := json.NewEncoder(b).Encode(payload)</span><br><span class="line">	<span class="keyword">if</span> encodeErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> encodeErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Everything we post to the S3 bucket should be marked &#x27;private&#x27;</span></span><br><span class="line">	<span class="keyword">var</span> acl = s3.Private</span><br><span class="line">	<span class="keyword">var</span> contentType = <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bucket.PutReader(storage_path, b, <span class="type">int64</span>(b.Len()), contentType, acl, s3.Options&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Go-routines-的傻瓜式用法"><a href="#Go-routines-的傻瓜式用法" class="headerlink" title="Go routines 的傻瓜式用法"></a>Go routines 的傻瓜式用法</h2><p>起初我们实现了一个非常简单的 POST 处理接口，尝试用一个简单的 goroutine 并行工作处理过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">payloadHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r.Method != <span class="string">&quot;POST&quot;</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read the body into a string for json decoding</span></span><br><span class="line">	<span class="keyword">var</span> content = &amp;PayloadCollection&#123;&#125;</span><br><span class="line">	err := json.NewDecoder(io.LimitReader(r.Body, MaxLength)).Decode(&amp;content)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=UTF-8&quot;</span>)</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Go through each payload and queue items individually to be posted to S3</span></span><br><span class="line">	<span class="keyword">for</span> _, payload := <span class="keyword">range</span> content.Payloads &#123;</span><br><span class="line">		<span class="keyword">go</span> payload.UploadToS3()   <span class="comment">// &lt;----- DON&#x27;T DO THIS</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.WriteHeader(http.StatusOK)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在普通负载的情况下，这段代码对于大多数人已经够用了，不过很快就被证明了不适合大流量的情形。当我们把第一个版本的代码部署到生产环境后，才发现实际情况远远超出我们的预期，系统流量比之前预计的大许多，我们低估了数据负载量。</p>
<p>上面的处理方式从几个方面来看都有问题。我们无法办法控制创建的 go routines 的数量。而且我们每分钟收到一百万次的 POST 请求，代码必然很快就崩溃。</p>
<h2 id="再次尝试"><a href="#再次尝试" class="headerlink" title="再次尝试"></a>再次尝试</h2><p>我们需要寻找别的出路。从一开始，我们就在讨论怎样保证请求处理时间较短，然后在后台进行工作处理。当然，在 Ruby on Rails 里必须这样做，否则你会阻塞掉所有的 web 处理进程，无论你是否使用了 puma，unicorn，passenger（我们这里就不讨论 JRuby 了）。然后我们可能会使用常见的解决方案，比如 Resque，Sidkiq，SQS，等等。有许多方法可以完成这个任务。</p>
<p>所以第二次迭代采用了缓冲通道（ buffered channel ），我们可以将一些工作先放入队列，再将它们上传至 S3，由于我们能够控制队列的大小，而且有充足的内存可用，所以我们以为将任务缓冲到 channel 队列中就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Queue <span class="keyword">chan</span> Payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Queue = <span class="built_in">make</span>(<span class="keyword">chan</span> Payload, MAX_QUEUE)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">payloadHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Go through each payload and queue items individually to be posted to S3</span></span><br><span class="line">    <span class="keyword">for</span> _, payload := <span class="keyword">range</span> content.Payloads &#123;</span><br><span class="line">        Queue &lt;- payload</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将任务从队列中取出再进行处理，我们使用了类似下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartProcessor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> job := &lt;-Queue:</span><br><span class="line">            job.payload.UploadToS3()  <span class="comment">// &lt;-- 仍然不好使！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老实说，我都不知道当时我们在想些什么。这一定是喝红牛熬夜导致的结果。这个方案没给我们带来任何好处，我们只是将一个有问题的并发过程替换为了一个缓冲队列，它只是将问题推后了而已。我们的同步处理过程每次只将一份载荷数据上传到 S3，由于接受到请求的速率远大于单例程上传到 S3 的能力，我们的缓冲队列很快就满了，导致请求处理过程阻塞，无法将更多的数据送入队列。</p>
<p>我们傻乎乎地忽略了问题，最终开始了系统的死亡倒计时。在部署了这个问题版本之后几分钟里，系统的延迟以固定的速率不断增加。</p>
<p><img src="https://img.zvz.im/imgs/2019/06/a7dd8e1bb4446be3.jpg" alt=""></p>
<h2 id="更好的解决方案"><a href="#更好的解决方案" class="headerlink" title="更好的解决方案"></a>更好的解决方案</h2><p>我们决定使用 Go 通道的一种常用模式构建一个两层的通道系统，一个通道用作任务队列，另一个来控制处理任务时的并发量。</p>
<p>这个办法是想以一种可持续的速率、并发地上传数据至 S3 存储，这样既不会把机器跑挂掉也不会产生 S3 的连接错误。因此我们选择使用了一种 Job/Worker 模式。如果你熟悉 Java，C# 等语言，可以认为这是使用通道以 Go 语言的方式实现了一个工作线程池。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	MaxWorker = os.Getenv(<span class="string">&quot;MAX_WORKERS&quot;</span>)</span><br><span class="line">	MaxQueue  = os.Getenv(<span class="string">&quot;MAX_QUEUE&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Job represents the job to be run</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">	Payload Payload</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A buffered channel that we can send work requests on.</span></span><br><span class="line"><span class="keyword">var</span> JobQueue <span class="keyword">chan</span> Job</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker represents the worker that executes the job</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	WorkerPool  <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">	JobChannel  <span class="keyword">chan</span> Job</span><br><span class="line">	quit    	<span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job)</span></span> Worker &#123;</span><br><span class="line">	<span class="keyword">return</span> Worker&#123;</span><br><span class="line">		WorkerPool: workerPool,</span><br><span class="line">		JobChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> Job),</span><br><span class="line">		quit:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start method starts the run loop for the worker, listening for a quit channel in</span></span><br><span class="line"><span class="comment">// case we need to stop it</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span></span> Start() &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// register the current worker into the worker queue.</span></span><br><span class="line">			w.WorkerPool &lt;- w.JobChannel</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> job := &lt;-w.JobChannel:</span><br><span class="line">				<span class="comment">// we have received a work request.</span></span><br><span class="line">				<span class="keyword">if</span> err := job.Payload.UploadToS3(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Errorf(<span class="string">&quot;Error uploading to S3: %s&quot;</span>, err.Error())</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> &lt;-w.quit:</span><br><span class="line">				<span class="comment">// we have received a signal to stop</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop signals the worker to stop listening for work requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span></span> Stop() &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		w.quit &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们修改了 web 请求处理过程，使用数据载荷创建了一个 <code>Job</code> 实例，然后将其送入 <code>JobQueue</code> 通道中供工作例程使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">payloadHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r.Method != <span class="string">&quot;POST&quot;</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the body into a string for json decoding</span></span><br><span class="line">	<span class="keyword">var</span> content = &amp;PayloadCollection&#123;&#125;</span><br><span class="line">	err := json.NewDecoder(io.LimitReader(r.Body, MaxLength)).Decode(&amp;content)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=UTF-8&quot;</span>)</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go through each payload and queue items individually to be posted to S3</span></span><br><span class="line">    <span class="keyword">for</span> _, payload := <span class="keyword">range</span> content.Payloads &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// let&#x27;s create a job with the payload</span></span><br><span class="line">        work := Job&#123;Payload: payload&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push the work onto the queue.</span></span><br><span class="line">        JobQueue &lt;- work</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 web 服务初始化的过程中，我们创建了一个 <code>Dispatcher</code> 实例，调用 <code>Run()</code> 方法创建了工作例程池，并且通过监听 <code>JobQueue</code> 获取工作任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatcher := NewDispatcher(MaxWorker) </span><br><span class="line">dispatcher.Run()</span><br></pre></td></tr></table></figure>
<p>下面的代码是任务分派器的具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dispatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// A pool of workers channels that are registered with the dispatcher</span></span><br><span class="line">	WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDispatcher</span><span class="params">(maxWorkers <span class="type">int</span>)</span></span> *Dispatcher &#123;</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> Job, maxWorkers)</span><br><span class="line">	<span class="keyword">return</span> &amp;Dispatcher&#123;WorkerPool: pool&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span></span> Run() &#123;</span><br><span class="line">    <span class="comment">// starting n number of workers</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; d.maxWorkers; i++ &#123;</span><br><span class="line">		worker := NewWorker(d.pool)</span><br><span class="line">		worker.Start()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> d.dispatch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span></span> dispatch() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> job := &lt;-JobQueue:</span><br><span class="line">			<span class="comment">// a job request has been received</span></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">				<span class="comment">// try to obtain a worker job channel that is available.</span></span><br><span class="line">				<span class="comment">// this will block until a worker is idle</span></span><br><span class="line">				jobChannel := &lt;-d.WorkerPool</span><br><span class="line"></span><br><span class="line">				<span class="comment">// dispatch the job to the worker job channel</span></span><br><span class="line">				jobChannel &lt;- job</span><br><span class="line">			&#125;(job)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们提供了一个最大数量的参数，用于控制工作池中初始的例程数量。因为这个项目使用了 Amazon Elasticbeanstalk 以及 docker 中的 Go 环境，所以我们努力遵循 <a target="_blank" rel="noopener" href="http://12factor.net/">12-factor</a> 的方法，从环境变量中读取配置值，便于在生产环境中进行系统配置。通过这种方式，我们可以控制工作例程的数量和工作队列的长度，无需对集群进行重新部署，我们就能快速调整参数值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ( </span><br><span class="line">  MaxWorker = os.Getenv(<span class="string">&quot;MAX_WORKERS&quot;</span>) </span><br><span class="line">  MaxQueue  = os.Getenv(<span class="string">&quot;MAX_QUEUE&quot;</span>) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在部署这份代码后，我们发现系统的延迟立刻大幅下降，而我们处理请求的能力得到了巨大的提升。</p>
<p><img src="https://img.zvz.im/imgs/2019/06/d21c1ec060f286f7.jpg" alt=""></p>
<p>在我们的 Elastic Load Balancers 全部预热完成几分钟后，可以看到我们的 ElasticBeanstalk 应用每分钟可以处理近一百万的请求，常常会在流量早高峰的时候突破每分钟一百万。</p>
<p>我们刚把新代码部署上去，服务器数量就从 100 台服务器大幅下降到大约 20 台服务器。</p>
<p><img src="https://img.zvz.im/imgs/2019/06/3c0a7a5f497861ed.jpg" alt=""></p>
<p>在我们调整集群配置和自动缩放配置后，我们能将服务器的使用数量降低到四个 EC2 c4.Large 实例，再将 Elastic Auto-Scaling 设置为 CPU 使用率持续五分钟超 90% 的时候，增加一个实例。</p>
<p><img src="https://img.zvz.im/imgs/2019/06/f1571f323aa5126a.jpg" alt=""></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在我的认知中，「简单化」才是常胜秘诀。我们本可能设计一个更复杂的系统，拥有许多队列和后台工作例程，部署也更复杂。但是我们最终利用了 Elasticbeanstalk 的自动缩放能力和 Go 语言为我们带来的高效简单的并发解决方案。</p>
<p>并不是每天都能发生这样的事情：一个只有四台机器集群处理着每分钟一百万的 POST 请求，把数据写入 Amazon S3 存储中，而且这些机器可能比我现在的 MacBook Pro 性能还差。</p>
<p>每件工作总会有更合适的工具。当你的 Ruby on Rails 系统需要强大的请求处理能力时，不妨尝试一下 ruby 生态圈外那些更加简单有效的解决方案。</p>
<p>翻译自：<a target="_blank" rel="noopener" href="https://medium.com/smsjunk/handling-1-million-requests-per-minute-with-golang-f70ac505fcaa">Handling 1 Million Requests per Minute with Golang</a></p>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/15/go-tensorflow/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          使用 Go 语言学会 Tensorflow
        
      </div>
    </a>
  
  
    <a href="/2017/12/12/javascript-async-await/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Javascript 异步探奇：Aysn/Await</div>
    </a>
  
</nav>

  
</article>

<script type='text/javascript'>window.notIndexPage = true;</script>


<section id="comments">
  <div id="disqus_thread">
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'imzvz'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>
    Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
  </div>
</section>
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>
      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	Linked with:&nbsp;&nbsp;&nbsp; 
	<a href="http://mritd.me" target="_blank">mritd.me</a>&nbsp;&nbsp;&nbsp;
	<a href="https://www.mghio.cn" target="_blank">mghio's blog</a>&nbsp;&nbsp;&nbsp;
	<a href="https://sillydong.com" target="_blank">傻东の学习笔记</a>&nbsp;&nbsp;&nbsp;
	</div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
</nav>
    
<script>
  var disqus_shortname = 'imzvz';
  
  var disqus_url = 'http://zvz.im/2018/02/28/handling-million-requests-with-golang/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>

<script>
  if(window.notIndexPage)
  $(function(){
    $.get('//manage.zvz.im/api/posts/adv', function(res) {
      if(res.data.length) {
        $.each(res.data, function(idx, adv) {
          if(idx == 0) {
            if($('h2:first').length > 0) {
              $(adv).insertBefore('h2:first');
              return;
            }
          }
          $(adv).insertAfter('.article-inner');
        });
      }
    });
  });
</script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/require.min.js"></script>


<script src="/js/script.js"></script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({{ JSON.stringify(config) }});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="{{ src }}">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>